// main.compact
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

// Ledger definitions
export ledger properties: Map<Bytes<32>, PropertyMeta>;
export ledger propertyIndex: List<Bytes<32>>;
export ledger round: Counter;

// Constructor
constructor() {
    // Counter defaults to 0 automatically
}

// Types
struct PropertyMeta {
    domainSep: Bytes<32>;
    tokenType: Bytes<32>;
    totalSupply: Uint<128>;
    registered: Boolean;
}

// Utilities
circuit deriveTokenType(domainSep: Bytes<32>): Bytes<32> {
    return tokenType(domainSep, kernel.self());
}

// Safe summation of coins of a specific token
pure circuit sumCoinsIfColor(acc: Uint<128>, coin: QualifiedCoinInfo, token: Bytes<32>): Uint<128> {
    const accF: Field = acc as Field;
    const addValue: Field = (coin.color == token ? coin.value as Field : 0 as Field);
    return (accF + addValue) as Uint<128>;
}

// Tokens
export circuit mintTokens(
    docHash: Bytes<32>,
    amount: Uint<128>,
    nonce: Bytes<32>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): CoinInfo {
    // Declare witness values inside the body
    let docHashW = witness docHash;
    let amountW = witness amount;
    let nonceW = witness nonce;
    let recipientW = witness recipient;

    assert(properties.member(docHashW), "property not registered");
    const meta = properties.lookup(docHashW);
    const domain = meta.domainSep;

    const minted = mintToken(domain, amountW as Uint<64>, nonceW, recipientW);

    const newSupply = (meta.totalSupply + amountW) as Uint<128>;
    const newMeta = PropertyMeta {
        domainSep: domain,
        tokenType: meta.tokenType,
        totalSupply: newSupply,
        registered: true
    };

    properties.insert(docHashW, newMeta);
    return minted;
}

// Burn tokens
export circuit burnCoinImmediate(docHash: Bytes<32>, coin: CoinInfo): [] {
    let docHashW = witness docHash;

    assert(properties.member(docHashW), "property not registered");
    const target = burnAddress();
    createZswapOutput(coin, target);
}

// Transfers
export circuit transferQualifiedCoin(
    inputCoin: QualifiedCoinInfo,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
): SendResult {
    let inputCoinW = witness inputCoin;
    let recipientW = witness recipient;
    let valueW = witness value;

    assert(valueW <= inputCoinW.value, "transfer value exceeds input coin value");
    return send(inputCoinW, recipientW, valueW);
}

// Verification
export circuit verifyOwnership(
    coins: Vector<8, QualifiedCoinInfo>,
    docHash: Bytes<32>,
    requiredAmount: Uint<128>
): Boolean {
    let docHashW = witness docHash;

    assert(properties.member(docHashW), "property not registered");
    const meta = properties.lookup(docHashW);
    const token = meta.tokenType;
    const tokenVec = [token, token, token, token, token, token, token, token];

    const totalHeld = fold(sumCoinsIfColor, 0 as Uint<128>, coins, tokenVec);
    return totalHeld >= requiredAmount as Uint<128>;
}

// Registry
export circuit registerProperty(docHash: Bytes<32>, domainSep: Bytes<32>): [] {
    let docHashW = witness docHash;
    let domainSepW = witness domainSep;

    assert(!properties.member(docHashW), "property already registered");

    const tok = deriveTokenType(domainSepW);
    const meta = PropertyMeta {
        domainSep: domainSepW,
        tokenType: tok,
        totalSupply: 0,
        registered: true
    };

    properties.insert(docHashW, meta);
    propertyIndex.pushFront(docHashW);
    round.increment(1);
}

// Read property meta
export circuit readPropertyMeta(docHash: Bytes<32>): PropertyMeta {
    let docHashW = witness docHash;

    assert(properties.member(docHashW), "property not registered");
    return properties.lookup(docHashW);
}
