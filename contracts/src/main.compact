pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

// Token states for advanced features
enum TokenState {
    Active,
    Paused,
    Frozen
}

// Enhanced ledger state for fungible token
export ledger total_supply: Uint<64>;
export ledger circulating_supply: Uint<64>;
export ledger nonce: Counter;

// Track token balances using bridge contract patterns
export ledger balances: Map<Uint<32>, Uint<64>>;
export ledger token_state: TokenState;

// Track token holders and metadata
export ledger holder_count: Uint<64>;
export ledger holders: Map<Uint<32>, Boolean>;

// Property details (publicly visible, sensitive details off-chain)
export ledger property_details: Map<Uint<32>, Bytes<64>>;

// Constructor to initialize the token
constructor() {
    total_supply = 0;
    circulating_supply = 0;
    token_state = TokenState.Active;
    holder_count = 0;
}

export circuit mint(
    to: Uint<32>,
    amount: Uint<64>
): [] {
    // Check token is active
    assert(token_state == TokenState.Active, "Token is not active");
    
    // Validate amount is positive
    assert(amount > 0, "Amount must be positive");
    
    // Get current balance or 0 if new holder
    const current_balance = balances.member(disclose(to)) 
        ? balances.lookup(disclose(to)) 
        : 0 as Uint<64>;
    
    // Update balance using bridge contract patterns
    balances.insert(disclose(to), (current_balance + disclose(amount)) as Uint<64>);
    
    // Track new holders
    if (!holders.member(disclose(to))) {
        holders.insert(disclose(to), true);
        holder_count = (holder_count + 1) as Uint<64>;
    }
    
    // Update total and circulating supply using proper type casting
    total_supply = (total_supply + disclose(amount)) as Uint<64>;
    circulating_supply = (circulating_supply + disclose(amount)) as Uint<64>;
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit transfer(
    from: Uint<32>,
    to: Uint<32>,
    amount: Uint<64>
): [] {
    // Check token is active
    assert(token_state == TokenState.Active, "Token is not active");
    
    // Validate amount is positive
    assert(amount > 0, "Amount must be positive");
    
    // Check sender has sufficient balance
    assert(balances.member(disclose(from)), "Sender has no balance");
    const from_balance = balances.lookup(disclose(from));
    assert(from_balance >= disclose(amount), "Insufficient balance");
    
    // Get recipient balance or 0 if new holder
    const to_balance = balances.member(disclose(to)) 
        ? balances.lookup(disclose(to)) 
        : 0 as Uint<64>;
    
    // Update balances using bridge contract patterns
    balances.insert(disclose(from), (from_balance - disclose(amount)) as Uint<64>);
    balances.insert(disclose(to), (to_balance + disclose(amount)) as Uint<64>);
    
    // Track new holders
    if (!holders.member(disclose(to))) {
        holders.insert(disclose(to), true);
        holder_count = (holder_count + 1) as Uint<64>;
    }
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit burn(
    from: Uint<32>,
    amount: Uint<64>
): [] {
    // Check token is active
    assert(token_state == TokenState.Active, "Token is not active");
    
    // Validate amount is positive
    assert(amount > 0, "Amount must be positive");
    
    // Check holder has sufficient balance
    assert(balances.member(disclose(from)), "Holder has no balance");
    const current_balance = balances.lookup(disclose(from));
    assert(current_balance >= disclose(amount), "Insufficient balance to burn");
    
    // Update balance using bridge contract patterns
    balances.insert(disclose(from), (current_balance - disclose(amount)) as Uint<64>);
    
    // Update total and circulating supply
    total_supply = (total_supply - disclose(amount)) as Uint<64>;
    circulating_supply = (circulating_supply - disclose(amount)) as Uint<64>;
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit set_property_details(
    property_id: Uint<32>,
    details_hash: Bytes<64>
): [] {
    // Set property details (e.g., hash of the property document)
    property_details.insert(disclose(property_id), disclose(details_hash));
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit pause_token(): [] {
    // Change token state to paused
    token_state = TokenState.Paused;
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit unpause_token(): [] {
    // Check token is currently paused
    assert(token_state == TokenState.Paused, "Token is not paused");
    
    // Change token state back to active
    token_state = TokenState.Active;
    
    // Increment nonce for state tracking
    nonce.increment(1);
}
