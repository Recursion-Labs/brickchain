// main.compact
pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

// Ledger definitions
export ledger properties: Map<Bytes<32>, PropertyMeta>;
export ledger propertyIndex: List<Bytes<32>>;
export ledger round: Counter;  // Counter defaults to 0 automatically

constructor() {
    // No assignment needed for Counter
}

// Types
struct PropertyMeta {
    domainSep: Bytes<32>;
    tokenType: Bytes<32>;
    totalSupply: Uint<128>;
    registered: Boolean;
}

// Utilities
pure circuit deriveTokenType(domainSep: Bytes<32>): Bytes<32> {
    return tokenType(domainSep, kernel.self());
}

// Safe sum of coins for verification
pure circuit sumCoinsIfColor(acc: Uint<254>, coin: QualifiedCoinInfo, token: Bytes<32>): Uint<254> {
    if (coin.color == token) {
        return acc + coin.value as Uint<254>;
    } else {
        return acc;
    }
}

// Tokens
export circuit mintTokens(
    docHash: Bytes<32>,
    amount: Uint<128>,
    nonce: Bytes<32>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): CoinInfo {
    assert(properties.member(docHash), "property not registered");
    const meta = properties.lookup(docHash);
    const domain = meta.domainSep;
    const minted = mintToken(domain, amount as Uint<64>, nonce, recipient); // cast to Uint<64>
    const newSupply = meta.totalSupply + amount;
    const newMeta = PropertyMeta {
        domainSep: domain,
        tokenType: meta.tokenType,
        totalSupply: newSupply,
        registered: true
    };
    properties.insert(docHash, newMeta);
    return minted;
}

export circuit burnCoinImmediate(docHash: Bytes<32>, coin: CoinInfo): [] {
    assert(properties.member(docHash), "property not registered");
    const target = burnAddress();
    createZswapOutput(coin, target);
}

// Transfers
export circuit transferQualifiedCoin(
    inputCoin: QualifiedCoinInfo,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    value: Uint<128>
): SendResult {
    assert(value <= inputCoin.value, "transfer value exceeds input coin value");
    const res = send(inputCoin, recipient, value);
    return res;
}

// Verification
export circuit verifyOwnership(
    coins: Vector<8, QualifiedCoinInfo>,
    docHash: Bytes<32>,
    requiredAmount: Uint<128>
): Boolean {
    assert(properties.member(docHash), "property not registered");
    const meta = properties.lookup(docHash);
    const token = meta.tokenType;
    const tokenVec = [token, token, token, token, token, token, token, token];
    const totalHeld = fold(sumCoinsIfColor, 0 as Uint<254>, coins, tokenVec);
    return totalHeld >= requiredAmount as Uint<254>;
}

// Registry
export circuit registerProperty(docHash: Bytes<32>, domainSep: Bytes<32>): [] {
    assert(!properties.member(docHash), "property already registered");
    const tok = deriveTokenType(domainSep);
    const meta = PropertyMeta {
        domainSep: domainSep,
        tokenType: tok,
        totalSupply: 0,
        registered: true
    };
    properties.insert(docHash, meta);
    propertyIndex.pushFront(docHash);
    round.increment();  // correct way to modify Counter
}

export circuit readPropertyMeta(docHash: Bytes<32>): PropertyMeta {
    assert(properties.member(docHash), "property not registered");
    return properties.lookup(docHash);
}
