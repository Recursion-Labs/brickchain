pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

// Token states for advanced features
enum TokenState {
    Active,
    Paused,
    Frozen
}

// Property status for tracking real-world property lifecycle
enum PropertyStatus {
    Registered,
    Tokenized,
    Transferred,
    Deactivated
}

// Enhanced ledger state for fungible token
export ledger total_supply: Uint<64>;
export ledger circulating_supply: Uint<64>;
export ledger nonce: Counter;

// Track token balances using bridge contract patterns
export ledger balances: Map<Uint<32>, Uint<64>>;
export ledger token_state: TokenState;

// Track token holders and metadata
export ledger holder_count: Uint<64>;
export ledger holders: Map<Uint<32>, Boolean>;

// Property-specific ledgers
export ledger property_statuses: Map<Bytes<32>, PropertyStatus>; // Property ID -> Status
export ledger property_owners: Map<Bytes<32>, Uint<32>>; // Property ID -> Owner ID
export ledger property_token_ids: Map<Bytes<32>, Uint<32>>; // Property ID -> Token ID (if 1:1 tokenization)

// Constructor to initialize the token
constructor() {
    total_supply = 0;
    circulating_supply = 0;
    token_state = TokenState.Active;
    holder_count = 0;
}

export circuit mint(
    to: Uint<32>,
    amount: Uint<64>
): [] {
    // Check token is active
    assert(token_state == TokenState.Active, "Token is not active");
    
    // Validate amount is positive
    assert(amount > 0, "Amount must be positive");
    
    // Get current balance or 0 if new holder
    const current_balance = balances.member(disclose(to)) 
        ? balances.lookup(disclose(to)) 
        : 0 as Uint<64>;
    
    // Update balance using bridge contract patterns
    balances.insert(disclose(to), (current_balance + disclose(amount)) as Uint<64>);
    
    // Track new holders
    if (!holders.member(disclose(to))) {
        holders.insert(disclose(to), true);
        holder_count = (holder_count + 1) as Uint<64>;
    }
    
    // Update total and circulating supply using proper type casting
    total_supply = (total_supply + disclose(amount)) as Uint<64>;
    circulating_supply = (circulating_supply + disclose(amount)) as Uint<64>;
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit transfer(
    from: Uint<32>,
    to: Uint<32>,
    amount: Uint<64>
): [] {
    // Check token is active
    assert(token_state == TokenState.Active, "Token is not active");
    
    // Validate amount is positive
    assert(amount > 0, "Amount must be positive");
    
    // Check sender has sufficient balance
    assert(balances.member(disclose(from)), "Sender has no balance");
    const from_balance = balances.lookup(disclose(from));
    assert(from_balance >= disclose(amount), "Insufficient balance");
    
    // Get recipient balance or 0 if new holder
    const to_balance = balances.member(disclose(to)) 
        ? balances.lookup(disclose(to)) 
        : 0 as Uint<64>;
    
    // Update balances using bridge contract patterns
    balances.insert(disclose(from), (from_balance - disclose(amount)) as Uint<64>);
    balances.insert(disclose(to), (to_balance + disclose(amount)) as Uint<64>);
    
    // Track new holders
    if (!holders.member(disclose(to))) {
        holders.insert(disclose(to), true);
        holder_count = (holder_count + 1) as Uint<64>;
    }
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit approve(
    owner: Uint<32>,
    spender: Uint<32>,
    amount: Uint<64>
): [] {
    // Check token is active
    assert(token_state == TokenState.Active, "Token is not active");
    
    // Validate amount is positive
    assert(amount > 0, "Amount must be positive");
    
    // Note: In a full implementation, you'd track allowances in a separate Map
    // For simplicity, this basic version just validates the parameters
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit burn(
    from: Uint<32>,
    amount: Uint<64>
): [] {
    // Check token is active
    assert(token_state == TokenState.Active, "Token is not active");
    
    // Validate amount is positive
    assert(amount > 0, "Amount must be positive");
    
    // Check holder has sufficient balance
    assert(balances.member(disclose(from)), "Holder has no balance");
    const current_balance = balances.lookup(disclose(from));
    assert(current_balance >= disclose(amount), "Insufficient balance to burn");
    
    // Update balance using bridge contract patterns
    balances.insert(disclose(from), (current_balance - disclose(amount)) as Uint<64>);
    
    // Update total and circulating supply
    total_supply = (total_supply - disclose(amount)) as Uint<64>;
    circulating_supply = (circulating_supply - disclose(amount)) as Uint<64>;
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit pause_token(): [] {
    // Change token state to paused
    token_state = TokenState.Paused;
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

export circuit unpause_token(): [] {
    // Check token is currently paused
    assert(token_state == TokenState.Paused, "Token is not paused");
    
    // Change token state back to active
    token_state = TokenState.Active;
    
    // Increment nonce for state tracking
    nonce.increment(1);
}

// Property-specific circuits
export circuit register_property(
    property_id: Bytes<32>,
    owner_id: Uint<32>
): [] {
    assert(!property_statuses.member(disclose(property_id)), "Property already registered");
    property_statuses.insert(disclose(property_id), PropertyStatus.Registered);
    property_owners.insert(disclose(property_id), disclose(owner_id));
    nonce.increment(1);
}

export circuit tokenize_property(
    property_id: Bytes<32>,
    token_id: Uint<32>
): [] {
    assert(property_statuses.member(disclose(property_id)), "Property not registered");
    assert(property_statuses.lookup(disclose(property_id)) == PropertyStatus.Registered, "Property not in Registered state");
    property_statuses.insert(disclose(property_id), PropertyStatus.Tokenized);
    property_token_ids.insert(disclose(property_id), disclose(token_id));
    nonce.increment(1);
}

export circuit transfer_property_ownership(
    property_id: Bytes<32>,
    new_owner_id: Uint<32>
): [] {
    assert(property_statuses.member(disclose(property_id)), "Property not registered");
    assert(property_owners.member(disclose(property_id)), "Property has no owner");
    property_owners.insert(disclose(property_id), disclose(new_owner_id));
    property_statuses.insert(disclose(property_id), PropertyStatus.Transferred);
    nonce.increment(1);
}

export circuit deactivate_property(
    property_id: Bytes<32>
): [] {
    assert(property_statuses.member(disclose(property_id)), "Property not registered");
    property_statuses.insert(disclose(property_id), PropertyStatus.Deactivated);
    nonce.increment(1);
}
